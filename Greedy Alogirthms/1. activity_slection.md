# Activity Selection (Interval Scheduling)

## Problem

You're given activities with start and end times. Select the maximum number of non-overlapping activities.

**Greedy choice:** Always pick the activity that finishes earliest.

**Why it works:** Finishing early leaves more room for future activities.

### Example

**Activities:** (start, end)
```
(1, 3), (2, 4), (3, 5), (0, 6), (5, 7)

Pick: (1,3) → (3,5) → (5,7)
```

---

## Greedy Approach

### Idea

1. Sort activities by end time
2. Pick the earliest finishing activity that doesn't overlap with the previously selected one
3. Repeat

### Properties

- **Time Complexity:** O(n log n) (for sorting)
- **Space Complexity:** O(n) (for storing result)
- **Works only for:** Unweighted activities
- **Proof:** Greedy-choice property + optimal substructure

### Steps

1. Sort activities by end time
2. Initialize `last_end = -∞`
3. For each activity `(s, e)`:
   - If `s >= last_end`: select it, update `last_end = e`
4. Return selected activities

---

## Python Implementation — Greedy

```python
def activity_selection_greedy(activities):
    # Sort by end time
    activities.sort(key=lambda x: x[1])
    
    selected = []
    last_end = float('-inf')
    
    for start, end in activities:
        if start >= last_end:
            selected.append((start, end))
            last_end = end
    
    return selected

# Example
activities = [(1,3), (2,4), (3,5), (0,6), (5,7)]
print(activity_selection_greedy(activities))
# Output: [(1, 3), (3, 5), (5, 7)]
```

---

## Dynamic Programming Approach (Optional)

### Idea

Define `dp[i]` = max number of activities from i-th activity onward

**Recurrence:**
$$dp[i] = \max(1 + dp[j] \text{ for all } j > i \text{ if } start[j] \geq end[i])$$

- Can handle weighted activities too
- Slower: O(n²) naive, O(n log n) with binary search optimization

### Python Implementation — DP (unweighted)

```python
def activity_selection_dp(activities):
    # Sort by start time
    activities.sort(key=lambda x: x[0])
    n = len(activities)
    
    # Initialize DP table
    dp = [0] * n
    
    # Precompute next compatible activity
    next_index = [n] * n
    for i in range(n):
        for j in range(i+1, n):
            if activities[j][0] >= activities[i][1]:
                next_index[i] = j
                break
    
    # Fill DP table from end
    for i in reversed(range(n)):
        take = 1 + (dp[next_index[i]] if next_index[i] < n else 0)
        skip = dp[i+1] if i+1 < n else 0
        dp[i] = max(take, skip)
    
    return dp[0]

# Example
activities = [(1,3), (2,4), (3,5), (0,6), (5,7)]
print(activity_selection_dp(activities))
# Output: 3
```

---

## Quick Exam Comparison

| Aspect | Greedy | DP (unweighted/weighted) |
|--------|--------|--------------------------|
| **Idea** | Earliest finish first | Explore all compatible future activities |
| **Time Complexity** | O(n log n) | O(n²) naive, O(n log n) optimized |
| **Space Complexity** | O(n) | O(n) |
| **Optimality** | ✅ Unweighted only | ✅ Works for weighted/unweighted |
| **Implementation** | Simple | Slightly more complex |

**Note:**
- Greedy returns the selected activities
- DP (basic version) returns max count
- Weighted DP can also compute max weight sum; greedy fails there
