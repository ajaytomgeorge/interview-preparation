# Jump Game

## Problem

Given array where each element is max jump length, can you reach the end?

**Greedy choice:** Track the farthest reachable index.

### Examples

```
[2,3,1,1,4] â†’ True
[3,2,1,0,4] â†’ False
```

---

## Problem Statement

You are given an integer array `nums` where each element represents the maximum jump length from that position.

- You start at index 0
- At index i, you can jump to any index in the range: i + 1 to i + nums[i]
- **Determine** whether it is possible to reach the last index

**Return** `True` if reachable, otherwise `False`.

---

## Examples

| Input | Output | Explanation |
|-------|--------|-------------|
| `[2,3,1,1,4]` | `True` | Jump 1 step to index 1, then 3 steps to index 4 |
| `[3,2,1,0,4]` | `False` | Always arrive at index 3; max jump = 0 |

---

## Greedy Approach

### Key Idea

Instead of trying all jump combinations, keep track of the farthest index reachable at any point.

### Greedy Observation

If at any index i, `i > farthest_reachable`, then index i is unreachable.

Since jumps are only forward, no future jump can fix this.

If the farthest reachable index reaches or exceeds the last index â†’ return `True`.

---

## Algorithm

1. Initialize `farthest = 0`
2. Traverse the array from index 0
3. For each index i:
   - If `i > farthest`, return `False`
   - Update `farthest = max(farthest, i + nums[i])`
4. If `farthest >= last index`, return `True`
5. If loop ends, return `True`

---

## Why Greedy Works

- `farthest` represents the maximum index reachable using any valid sequence of jumps
- If an index is unreachable, it cannot be used to jump further
- Therefore, greedy reachability checking is sufficient

---

## Example Walkthrough

### Example 1: `[2,3,1,1,4]`

| Index | nums[i] | farthest | Reachable? |
|-------|---------|----------|-----------|
| 0 | 2 | 2 | âœ… |
| 1 | 3 | 4 | âœ… |

âœ” Reached last index â†’ **True**

### Example 2: `[3,2,1,0,4]`

| Index | nums[i] | farthest | Reachable? |
|-------|---------|----------|-----------|
| 0 | 3 | 3 | âœ… |
| 1 | 2 | 3 | âœ… |
| 2 | 1 | 3 | âœ… |
| 3 | 0 | 3 | âœ… |
| 4 | â€” | â€” | âŒ unreachable |

âœ– Cannot reach index 4 â†’ **False**

---

## Python Code (Exam Ready)

```python
def can_jump(nums):
    farthest = 0
    last_index = len(nums) - 1

    for i in range(len(nums)):
        # If current index is not reachable
        if i > farthest:
            return False

        # Update the farthest reachable index
        farthest = max(farthest, i + nums[i])

        # If end is reachable
        if farthest >= last_index:
            return True

    return True
```

---

## Time and Space Complexity

| Metric | Value |
|--------|-------|
| **Time Complexity** | O(n) |
| **Space Complexity** | O(1) |

---

## One-Line Exam Answer

The Jump Game can be solved using a greedy approach by tracking the farthest reachable index and determining whether the last index is reachable.

---

## Key Takeaways for Exam

- Problem asks for existence of a jump sequence
- Greedy tracks reachability, not paths
- If an index is unreachable, no future jumps can help
- Efficient solution in O(n) time

---

## Alternative: Dynamic Programming

### Idea

Define `dp[i]` = `True` if index i is reachable, `False` otherwise

### State Transition

Index i is reachable if there exists a previous index j such that:
- `dp[j] == True` AND
- `j + nums[j] >= i`

### Python Implementation

```python
def can_jump_dp(nums):
    n = len(nums)
    dp = [False] * n
    dp[0] = True

    for i in range(1, n):
        for j in range(i):
            if dp[j] and j + nums[j] >= i:
                dp[i] = True
                break

    return dp[-1]
```

### Complexity

| Metric | Value |
|--------|-------|
| **Time** | O(nÂ²) |
| **Space** | O(n) |

---

## Why Greedy Is Better Than DP

**DP does this:**
- Checks all possible jump sources
- Explicitly tests reachability

**Greedy does this:**
- Maintains the maximum reachable index
- Stops immediately when unreachable

ðŸ’¡ **Greedy is just a compressed version of DP**
