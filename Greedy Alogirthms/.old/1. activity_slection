#Activity Selection (Interval Scheduling)

Problem
You’re given activities with start and end times. Select the maximum number of non-overlapping activities.

Greedy choice
Always pick the activity that finishes earliest.

Why it works
Finishing early leaves more room for future activities.

Example

Activities: (start, end)
(1, 3), (2, 4), (3, 5), (0, 6), (5, 7)

Pick:
(1,3) → (3,5) → (5,7)

solution
1️⃣ Greedy Approach
Idea

Sort activities by end time

Pick the earliest finishing activity that doesn’t overlap with the previously selected one

Repeat

Properties

Time Complexity: O(n log n) (for sorting)

Space Complexity: O(n) (for storing result)

Works only for unweighted activities

Proof: Greedy-choice property + optimal substructure

Steps

Sort activities by end time

Initialize last_end = -∞

For each activity (s, e):

If s >= last_end: select it, update last_end = e

Return selected activities

Python Implementation — Greedy
def activity_selection_greedy(activities):
    # Sort by end time
    activities.sort(key=lambda x: x[1])
    
    selected = []
    last_end = float('-inf')
    
    for start, end in activities:
        if start >= last_end:
            selected.append((start, end))
            last_end = end
    
    return selected

# Example
activities = [(1,3), (2,4), (3,5), (0,6), (5,7)]
print(activity_selection_greedy(activities))
# Output: [(1, 3), (3, 5), (5, 7)]


Solutio9n2 to be aware
2️⃣ Dynamic Programming Approach (Optional)
Idea

Define dp[i] = max number of activities from i-th activity onward

Recurrence:

dp[i] = max(1 + dp[j] for all j > i if start[j] >= end[i])


Can handle weighted activities too

Slower: O(n²) naive, O(n log n) with binary search optimization

Python Implementation — DP (unweighted)
def activity_selection_dp(activities):
    # Sort by start time
    activities.sort(key=lambda x: x[0])
    n = len(activities)
    
    # Initialize DP table
    dp = [0] * n
    
    # Precompute next compatible activity
    next_index = [n] * n
    for i in range(n):
        for j in range(i+1, n):
            if activities[j][0] >= activities[i][1]:
                next_index[i] = j
                break
    
    # Fill DP table from end
    for i in reversed(range(n)):
        take = 1 + (dp[next_index[i]] if next_index[i] < n else 0)
        skip = dp[i+1] if i+1 < n else 0
        dp[i] = max(take, skip)
    
    return dp[0]

# Example
activities = [(1,3), (2,4), (3,5), (0,6), (5,7)]
print(activity_selection_dp(activities))
# Output: 3


Notes:

Greedy returns the selected activities

DP (basic version) returns max count

Weighted DP can also compute max weight sum, greedy fails there

✅ Quick Exam Comparison
Aspect	Greedy	DP (unweighted/weighted)
Idea	Earliest finish first	Explore all compatible future activities
Time Complexity	O(n log n)	O(n²) naive, O(n log n) optimized
Space Complexity	O(n)	O(n)
Optimality	✅ Unweighted only	✅ Works for weighted/unweighted
Implementation	Simple	Slightly more complex