Jump Game

Problem
Given array where each element is max jump length, can you reach the end?

Greedy choice
Track the farthest reachable index.

Example

[2,3,1,1,4] â†’ True
[3,2,1,0,4] â†’ False

âœ… Jump Game
ğŸ“Œ Problem Statement

You are given an integer array nums where each element represents the maximum jump length from that position.

You start at index 0

At index i, you can jump to any index in the range
i + 1 to i + nums[i]

Determine whether it is possible to reach the last index

Return True if reachable, otherwise False.

ğŸ“Œ Example
Input:  [2,3,1,1,4]
Output: True

Input:  [3,2,1,0,4]
Output: False

ğŸ§  Greedy Approach
Key Idea

Instead of trying all jump combinations, keep track of the farthest index reachable at any point.

ğŸ”‘ Greedy Observation

If at any index i,
i > farthest_reachable, then index i is unreachable

Since jumps are only forward, no future jump can fix this

If the farthest reachable index reaches or exceeds the last index â†’ return True

ğŸ§  Algorithm

Initialize farthest = 0

Traverse the array from index 0

For each index i:

If i > farthest, return False

Update farthest = max(farthest, i + nums[i])

If farthest â‰¥ last index, return True

If loop ends, return True

ğŸ§  Why Greedy Works

farthest represents the maximum index reachable using any valid sequence of jumps

If an index is unreachable, it cannot be used to jump further

Therefore, greedy reachability checking is sufficient

ğŸ§ª Example Walkthrough
Example 1:
nums = [2,3,1,1,4]

Index	nums[i]	farthest
0	2	2
1	3	4

âœ” Reached last index â†’ True

Example 2:
nums = [3,2,1,0,4]

Index	nums[i]	farthest
0	3	3
1	2	3
2	1	3
3	0	3
4	â€”	âŒ unreachable

âœ– Cannot reach index 4 â†’ False

ğŸ§‘â€ğŸ’» Python Code (Exam Ready)
def can_jump(nums):
    farthest = 0
    last_index = len(nums) - 1

    for i in range(len(nums)):
        # If current index is not reachable
        if i > farthest:
            return False

        # Update the farthest reachable index
        farthest = max(farthest, i + nums[i])

        # If end is reachable
        if farthest >= last_index:
            return True

    return True

â± Time and Space Complexity
Metric	Value
Time Complexity	O(n)
Space Complexity	O(1)
ğŸ“Œ One-Line Exam Answer

The Jump Game can be solved using a greedy approach by tracking the farthest reachable index and determining whether the last index is reachable.

âœ… Key Takeaways for Exam

Problem asks for existence of a jump sequence

Greedy tracks reachability, not paths

If an index is unreachable, no future jumps can help

Efficient solution in O(n) time


Dyanmic Programming
Below is the DP (Dynamic Programming) solution to Jump Game, written in a clear exam-oriented format, and then compared with the greedy approach so you see why greedy is enough.

âœ… Jump Game â€” DP Solution
ğŸ“Œ Problem Statement (Same)

Given an array nums where nums[i] is the maximum jump length from index i, determine if you can reach the last index starting from index 0.

ğŸ§  DP Idea

Define:

dp[i] = True  â†’ index i is reachable
dp[i] = False â†’ index i is not reachable

ğŸ” State Transition

Index i is reachable if there exists a previous index j such that:

dp[j] == True  AND  j + nums[j] >= i

ğŸ§  Initialization
dp[0] = True   # starting position
dp[i] = False for all i > 0

ğŸ§® Algorithm

Create a boolean DP array of size n

Set dp[0] = True

For every index i from 1 to n-1

Check all previous indices j < i

If any j can reach i, mark dp[i] = True

Return dp[n-1]

ğŸ§ª Example Walkthrough
nums = [2,3,1,1,4]

i	dp[i]	Reason
0	True	Start
1	True	0+2 â‰¥ 1
2	True	0+2 â‰¥ 2
3	True	1+3 â‰¥ 3
4	True	1+3 â‰¥ 4

âœ” Reachable

âŒ Example Where It Fails
nums = [3,2,1,0,4]

i	dp[i]
0	True
1	True
2	True
3	True
4	False

âœ– Cannot reach last index

ğŸ§‘â€ğŸ’» Python DP Code (Exam Style)
def can_jump_dp(nums):
    n = len(nums)
    dp = [False] * n
    dp[0] = True

    for i in range(1, n):
        for j in range(i):
            if dp[j] and j + nums[j] >= i:
                dp[i] = True
                break

    return dp[-1]

â± Complexity
Metric	Value
Time Complexity	O(nÂ²)
Space Complexity	O(n)
ğŸ¤” Why Greedy Is Better Than DP
DP does this:

Checks all possible jump sources

Explicitly tests reachability

Greedy does this:

Maintains the maximum reachable index

Stops immediately when unreachable

ğŸ’¡ Greedy is just a compressed version of DP