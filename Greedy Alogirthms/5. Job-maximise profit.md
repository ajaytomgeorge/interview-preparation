# Job Sequencing with Deadlines

## Problem

Each job has a deadline and profit. Do jobs to maximize profit (1 job per unit time).

**Greedy choice:**
- Sort jobs by profit (descending)
- Schedule each job as late as possible before its deadline

### Example

**Jobs:** (profit, deadline)
```
A (100, 2)
B (19, 1)
C (27, 2)
D (25, 1)

Optimal profit = 127
```

---

## Plain English Explanation

You are given jobs. Each job:
- Takes exactly 1 unit of time
- Must be done before a deadline
- Gives you some profit

üëâ You can do only ONE job at a time  
üëâ Your goal is to earn maximum total profit

---

## Real-Life Analogy

Imagine you run a small workshop:
- You can do only one job per day
- Each job:
  - Must be finished before a certain day
  - Pays you some money
- üí° You want to choose which jobs to do and when to earn maximum money

---

## Example

| Job | Deadline | Profit |
|-----|----------|--------|
| A | 2 | 100 |
| B | 1 | 19 |
| C | 2 | 27 |
| D | 1 | 25 |
| E | 3 | 15 |

**What does this mean?**
- Job A must be done by day 2
- Job B must be done by day 1
- Job E must be done by day 3
- Each job takes 1 day

---

## Time Slots Visualization

**Maximum deadline = 3**

So we have 3 time slots:

```
Day 1 | Day 2 | Day 3
```

We can place only one job per day.

---

## Why Can't We Do All Jobs?

There are 5 jobs but only 3 days ‚Üí impossible to do all.  
So we must choose wisely.

---

## Greedy Idea (Core Insight)

1Ô∏è‚É£ Pick jobs with highest profit first  
2Ô∏è‚É£ Do them as late as possible before their deadline

**Why late?**  
üëâ To keep earlier days free for other jobs.

---

## Step-by-Step Scheduling

### Step 1: Sort by profit (descending)

```
A(100), C(27), D(25), B(19), E(15)
```

### Step 2: Try to place each job

**Job A (deadline = 2)**
- Place it on Day 2
```
Day 1 | Day 2 | Day 3
  -   |   A   |   -
```

**Job C (deadline = 2)**
- Day 2 is full ‚Üí try Day 1
```
Day 1 | Day 2 | Day 3
  C   |   A   |   -
```

**Job D (deadline = 1)**
- Day 1 is full ‚Üí ‚ùå skip

**Job B (deadline = 1)**
- Day 1 is full ‚Üí ‚ùå skip

**Job E (deadline = 3)**
- Place on Day 3
```
Day 1 | Day 2 | Day 3
  C   |   A   |   E
```

---

## Final Result

**Jobs done:** C, A, E  
**Total profit** = 27 + 100 + 15 = **142**

---

## Why Greedy Works Here

- High-profit jobs are more important
- Scheduling late avoids blocking other jobs
- Local optimal decisions lead to global optimal profit

---

## One-Line Exam Explanation

Job Sequencing with Deadlines schedules jobs by sorting them in descending profit order and placing each job in the latest available slot before its deadline to maximize total profit.

---

## Key Takeaway

| Concept | Meaning |
|---------|---------|
| **1 job per unit time** | Can't do two jobs on same day |
| **Deadline** | Last day job can be done |
| **Greedy choice** | Highest profit first, schedule latest |
| **Why it works** | Leaves room for future jobs |

---

## Python Implementation

```python
def job_sequencing(jobs):
    """
    jobs: list of tuples (profit, deadline)
    returns: max profit and selected jobs
    """
    # Sort by profit (descending)
    jobs.sort(key=lambda x: -x[0])
    
    # Find maximum deadline
    max_deadline = max(job[1] for job in jobs)
    
    # Create slot array
    slots = [False] * (max_deadline + 1)
    selected_jobs = []
    total_profit = 0
    
    for profit, deadline in jobs:
        # Try to place job in latest available slot before deadline
        for j in range(deadline, 0, -1):
            if not slots[j]:
                slots[j] = True
                selected_jobs.append((profit, deadline))
                total_profit += profit
                break
    
    return total_profit, selected_jobs

# Example
jobs = [(100, 2), (19, 1), (27, 2), (25, 1), (15, 3)]
profit, selected = job_sequencing(jobs)
print(f"Max Profit: {profit}")
print(f"Selected Jobs: {selected}")
```

---

## Complexity Analysis

| Metric | Value |
|--------|-------|
| **Time** | O(n¬≤ + n log n) = O(n¬≤) in worst case |
| **Space** | O(n) for slots array |
