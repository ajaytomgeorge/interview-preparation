1️⃣ Sliding Window
a) "Substring" with conditions

Problem:
Given a string s and an integer k, find the length of the longest substring that contains at most k distinct characters.

Solution (Python):

def longest_substring_k_distinct(s, k):
    from collections import defaultdict
    left = 0
    max_len = 0
    freq = defaultdict(int)

    for right in range(len(s)):
        freq[s[right]] += 1

        while len(freq) > k:
            freq[s[left]] -= 1
            if freq[s[left]] == 0:
                del freq[s[left]]
            left += 1

        max_len = max(max_len, right - left + 1)
    return max_len

# Example
print(longest_substring_k_distinct("eceba", 2))  # Output: 3 ("ece")

b) "Subarray" with fixed/variable size

Problem:
Given an array of integers, find the maximum sum of a subarray with size k.

Solution:

def max_sum_subarray(arr, k):
    window_sum = sum(arr[:k])
    max_sum = window_sum

    for i in range(k, len(arr)):
        window_sum += arr[i] - arr[i - k]
        max_sum = max(max_sum, window_sum)
    return max_sum

# Example
print(max_sum_subarray([2,1,5,1,3,2], 3))  # Output: 9 ([5,1,3])

c) "Maximum/minimum window"

Problem:
Given an array, find the minimum-length subarray whose sum is greater than or equal to a given number s.

Solution:

def min_subarray_len(s, nums):
    left = 0
    current_sum = 0
    min_len = float('inf')

    for right in range(len(nums)):
        current_sum += nums[right]
        while current_sum >= s:
            min_len = min(min_len, right - left + 1)
            current_sum -= nums[left]
            left += 1

    return 0 if min_len == float('inf') else min_len

# Example
print(min_subarray_len(7, [2,3,1,2,4,3]))  # Output: 2 ([4,3])

d) "Contains all"

Problem:
Given strings s and t, find the smallest window in s which contains all the characters of t.

Solution:

def min_window(s, t):
    from collections import Counter

    if not s or not t:
        return ""

    dict_t = Counter(t)
    required = len(dict_t)
    l, r = 0, 0
    formed = 0
    window_counts = {}
    ans = float("inf"), None, None

    while r < len(s):
        character = s[r]
        window_counts[character] = window_counts.get(character, 0) + 1

        if character in dict_t and window_counts[character] == dict_t[character]:
            formed += 1

        while l <= r and formed == required:
            character = s[l]
            if r - l + 1 < ans[0]:
                ans = (r - l + 1, l, r)
            window_counts[character] -= 1
            if character in dict_t and window_counts[character] < dict_t[character]:
                formed -= 1
            l += 1
        r += 1

    return "" if ans[0] == float("inf") else s[ans[1]: ans[2]+1]

# Example
print(min_window("ADOBECODEBANC", "ABC"))  # Output: "BANC"

2️⃣ HashMap